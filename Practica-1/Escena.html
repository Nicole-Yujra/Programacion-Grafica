<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="refresh" content="4" > 
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escena</title>
</head>
<body style="background-color: rgb(7, 11, 49);" >
    <canvas id = "webglcanvas"  style = "border-radius: 2%;" width = "600" height = "600"></canvas>   
    <script id = "vs" type = "vertex">
        #version 300 es
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista;
        uniform mat4 uMatrizModelo;
        layout (location = 0) in vec2 aVertices; // (x,y) 
        layout (location = 1) in vec4 aColores; // (r,b,g,a) 
        out vec4 vColores;               // enviamos al shader de frag
        void main() {
            vColores = aColores;
            gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
        }
    </script>
    <script id = "fs" type = "fragment">
        #version 300 es
        precision mediump float;
        in vec4 vColores; //recepcionando el vector de colores
        out vec4 color;

        void main() {
            color = vColores;
          
        }
    </script>
    <script>
        /* Variables globales */
        let programaID;
        let gl,canvas;
        let circulo;   //buffers
        let estre;

        /* Variables Uniformes */
        let uMatrizProyeccion;
        let uMatrizVista;
        let uMatrizModelo;

        /* Matrices */
        let MatrizProyeccion = new Array(16);
        let MatrizVista = new Array(16);
        let MatrizModelo = new Array(16);

        /* Matriz Identidad */
        function identidad(r) {
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Traslación - glTranslatef */
        function traslacion(matriz, tx, ty, tz) {
          let r = new Array(16);
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
          multiplica(matriz, matriz, r);
        }

        /* Proyección Paralela - glOrtho */
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
          r[0] = 2/(der - izq); r[4] =             0; r[ 8] =                  0; r[12] =         -(der + izq)/(der - izq);
          r[1] =             0; r[5] = 2/(arr - abj); r[ 9] =                  0; r[13] =         -(arr + abj)/(arr - abj);
          r[2] =             0; r[6] =             0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
          r[3] =             0; r[7] =             0; r[11] =                  0; r[15] =                                1;
        }

        function multiplica(c, a, b) {
          let r = new Array(16);
          let i, j, k;
          for (i = 0; i < 4; i++){
            for (j = 0; j < 4; j++){
              let s = 0;
              for (k = 0; k < 4; k++)
                s = s + a[i + k * 4] * b[k + j * 4];
                r[i + j * 4] = s;
              }
            }
          for (i = 0; i < 16; i++)
            c[i] = r[i];
        }

        //generar circulo
        function circunferencia(radio,r,g,b){
            /* Las coordenadas cartesianas (x, y) */
            let vertices = [];

            /* Los colores x c/vértice (r,g,b,a) */
            let colores = [];

            /* Lee los vértices (x,y) y colores (r,g,b,a) */
            for (let i = 0; i < 360; i++) {
                //coordenadas pólares
                vertices.push(radio * Math.cos(i * Math.PI / 180));  //x
                vertices.push(radio * Math.sin(i * Math.PI / 180));  //y

                colores.push(r);
                colores.push(g);
                colores.push(b);
                colores.push(1);
            }

            circulo = gl.createVertexArray();
            gl.bindVertexArray(circulo);

            let codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            //-----------------------
            let codigoColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            // copiamos 1 arriba y abajo
            gl.enableVertexAttribArray(1);
            // el 4 por codigo rgba
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
            //--------------------
            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

        }


        //----------------------------------------------------------
        function lineas(radio,r,g,b){
            /* Las coordenadas cartesianas (x, y) */
            let vertices = [];
            /* Los colores x c/vértice (r,g,b,a) */
            let colores = [];
            /* Lee los vértices (x,y) y colores (r,g,b,a) */
            for (let i = 35; i < 40; i++) {
                //coordenadas pólares
                vertices.push(radio * Math.cosh(i * Math.PI / 180));  //x
                vertices.push(radio * Math.sin(i * Math.PI / 180));  //y

                colores.push(r);
                colores.push(g);
                colores.push(b);
                colores.push(1);
            }

            estre = gl.createVertexArray();
            gl.bindVertexArray(estre);

            let codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            //-----------------------
            let codigoColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            // copiamos 1 arriba y abajo
            gl.enableVertexAttribArray(1);
            // el 4 por codigo rgba
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
            //--------------------
            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        //-------------------------------------------------------------

        //-------------------------------------------------------------
        function main(){
            canvas = document.getElementById("webglcanvas");
            gl = canvas.getContext("webgl2");
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            // compila shader de vertice
            var shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(shaderDeVertice,document.getElementById("vs").text.trim());
            gl.compileShader(shaderDeVertice); 
            // compila shader de fragmento
            var shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
            gl.compileShader(shaderDeFragmento); 
            // enlazar ambos
            var programaID = gl.createProgram();
            gl.attachShader(programaID, shaderDeVertice); 
            gl.attachShader(programaID, shaderDeFragmento);
            gl.linkProgram(programaID);
            gl.useProgram(programaID);

            uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
            uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
            uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
            
            // izquierda derecha abajo arriba 
            ortho(MatrizProyeccion, -5, 5, -5, 5, -1, 1);
            gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
            
            /* Matriz del Modelo */
            identidad(MatrizVista);
            gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
            
            
            gl.clearColor(0,0,0, 1); // r g b a 255 177 100
            gl.clear(gl.COLOR_BUFFER_BIT);

            //----------BURBUJAS----------------------------------
            for (let index = 0; index < 35; index++) {
            
                identidad(MatrizModelo);
                traslacion(MatrizModelo, Math.random()*10-5, Math.random()*10-5, 0);
                // Se envia la Matriz del Modelo al shader
                // traslacion(MatrizModelo, 0,0, 0);
                gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
                let radio = Math.random();
                if (radio>0.3) {
                    circunferencia(radio,1,1,1);  //geometria 
                    gl.bindVertexArray(circulo);
                    gl.drawArrays(gl.LINE_LOOP, 0, 360);

                    circunferencia(radio-0.06,0,0,1);  //geometria 
                    gl.bindVertexArray(circulo);
                    gl.drawArrays(gl.TRIANGLE_FAN, 0,70);
                    circunferencia(radio-0.12,0,1,1);  //geometria 
                    gl.bindVertexArray(circulo);
                    gl.drawArrays(gl.TRIANGLE_FAN, 1, 66);
                    circunferencia(radio-0.18,1,1,1);  //geometria 
                    gl.bindVertexArray(circulo);
                    gl.drawArrays(gl.TRIANGLE_FAN, 4, 60);
                    circunferencia(radio-0.22,0,0,0);  //geometria 
                    gl.bindVertexArray(circulo);
                    gl.drawArrays(gl.TRIANGLE_FAN, 5, 58);

                    circunferencia(radio-0.05,0,0,1);  //geometria 
                    gl.bindVertexArray(circulo);
                    gl.drawArrays(gl.TRIANGLE_FAN, 200,35);
                    circunferencia(radio-0.08,0,1,1);  //geometria 
                    gl.bindVertexArray(circulo);
                    gl.drawArrays(gl.TRIANGLE_FAN, 201, 32);
                    circunferencia(radio-0.11 ,1,1,1);  //geometria 
                    gl.bindVertexArray(circulo);
                    gl.drawArrays(gl.TRIANGLE_FAN, 202, 30);
                    
                }
                //-------------------------------------------------  
            }
            //--------------puntitos de fondo-----------------
            for (let index = 0; index < 200; index++) {
                identidad(MatrizModelo);
                traslacion(MatrizModelo, Math.random()*10-5, Math.random()*10-5, 0);
                // Se envia la Matriz del Modelo al shader
                gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
                //circulo 1

                circunferencia(Math.random()*0.03,Math.random(),1,1);  //geometria 
                gl.bindVertexArray(circulo);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 360);
            }
            //--------------------------------------------
            for (let index = 0; index < 65; index++) {
                identidad(MatrizModelo);
                traslacion(MatrizModelo, Math.random()*10-5, Math.random()*10-5, 0);
                gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
                lineas(0.4,Math.random(),1,1);
                gl.bindVertexArray(estre);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 360);
            }

        }
        window.onload = main;
    </script> 
    <script ></script>
</body>
</html>