<!DOCTYPE HTML>
<html>
<head>
    <title>    Conecta 4  </title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />
    <style>
        body {
            background-color: rgb(236, 236, 236);
        }
        .container-fluid {
            min-height: 100vh;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="row align-items-center">
            <div class="col-lg-3 col-md-12 text-center text-lg-start">
                <h1>CONECTA 4</h1>
                <p style="font-size: large;">El primer jugador en alinear cuatro fichas de un mismo color en una fila continua ya sea de forma horizontal, vertical o diagonal antes que su oponente gana</p>
            </div>
            <div class="col-lg-7 col-md-10  text-center">
                <canvas id="webglcanvas" style="border-radius: 5%; margin-top: 2%;" width="550" height="550"></canvas>
                <h3 id="turno-jugador" style="color: rgb(255, 255, 255); margin-top: -6.5%;">Turno del jugador: Rojo</h3>
            </div>
        </div>
    </div>
    <script id="vs" type="vertex">
        #version 300 es
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista;
        uniform mat4 uMatrizModelo;
        layout(location = 0) in vec2 aVertices;
        layout(location = 1) in vec4 aColores;
        out vec4 vColores;
        void main() {
            vColores = aColores;  
            gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
        }
    </script>

    <script id="fs" type="fragment">
        #version 300 es
        precision mediump float;
        in vec4 vColores;
        out vec4 color;
        void main() {
            color = vColores;
        }
    </script>
	
    <script>
        'use strict';
        /* Variables globales */
        var programaID;
        var gl;
        var circulo;
        var canvas;

        /* Ancho y Alto */
        const ancho = 550;
        const alto = 550;
        // matriz del juego 
        const filas = 6;
        const columnas = 7;
        /* Variables Uniformes */
        var uMatrizProyeccion;
        var uMatrizVista;
        var uMatrizModelo;

        /* Matrices */
        var MatrizProyeccion = new Array(16);
        var MatrizVista = new Array(16);
        var MatrizModelo = new Array(16);

        // Matris de colores almacenados 
        let matrizColores = [];
        let turnoJugador = 1; // 1: Rojo, 2: Amarillo
        let turnoTexto = document.getElementById("turno-jugador");

        function compilaEnlazaLosShaders() {
            /* Se compila el shader de vertice */
            var shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
            gl.compileShader(shaderDeVertice);
            if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shaderDeVertice));
            }
            /* Se compila el shader de fragmento */
            var shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
            gl.compileShader(shaderDeFragmento);
            if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shaderDeFragmento));
            }

            /* Se enlaza ambos shader */
            programaID = gl.createProgram();
            gl.attachShader(programaID, shaderDeVertice); 
            gl.attachShader(programaID, shaderDeFragmento);
            gl.linkProgram(programaID);
            if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(programaID));
            }

            /* Se instala el programa de shaders para utilizarlo */
            gl.useProgram(programaID);
        }

        /* Convierte de grados a radianes */
        function toRadians(grados) {
            return grados * Math.PI / 180;
        };

        /* Matriz Identidad */
        function identidad(r) {
            r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
            r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Traslación - glTranslatef */
        function traslacion(matriz, tx, ty, tz) {
            var r = new Array(16);
            r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
            r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
            multiplica(matriz, matriz, r);
        }

        /* Proyección Paralela - glOrtho */
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
            r[0] = 2/(der - izq); r[4] =             0; r[ 8] =                  0; r[12] =         -(der + izq)/(der - izq);
            r[1] =             0; r[5] = 2/(arr - abj); r[ 9] =                  0; r[13] =         -(arr + abj)/(arr - abj);
            r[2] =             0; r[6] =             0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
            r[3] =             0; r[7] =             0; r[11] =                  0; r[15] =                                1;
        }
        /* Multiplicación de matrices de 4 x 4 */
        function multiplica(c, a, b) {
            let r = new Array(16);
            let i, j, k;
            for (i = 0; i < 4; i++){
                for (j = 0; j < 4; j++){
                let s = 0;
                for (k = 0; k < 4; k++)
                    s = s + a[i + k * 4] * b[k + j * 4];
                    r[i + j * 4] = s;
                }
                }
            for (i = 0; i < 16; i++)
                c[i] = r[i];
        }

        class Circulo {
            constructor(gl, radio) {
                this.gl = gl;
                this.radio = radio;
                this.circuloVAO = gl.createVertexArray();

                gl.bindVertexArray(this.circuloVAO);

                var codigoVertices = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
                var vertices = [];
                for (var i = 0; i < 360; i++) {
                    vertices.push(radio * Math.cos(i * Math.PI / 180));
                    vertices.push(radio * Math.sin(i * Math.PI / 180));
                }
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);//
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

                this.codigoColores = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.codigoColores);
                gl.enableVertexAttribArray(1);//
                gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);//

                gl.bindVertexArray(null);//
                gl.bindBuffer(gl.ARRAY_BUFFER, null);//
            }

            actualizaColor(colores) {
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.codigoColores);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colores), this.gl.STATIC_DRAW);
            }

            dibuja(gl, llenado) {
                gl.bindVertexArray(this.circuloVAO);
                gl.drawArrays((llenado) ? gl.TRIANGLE_FAN : gl.LINE_LOOP, 0, 360);
                gl.bindVertexArray(null);

            }
        }

        function distancia2(x1, y1, x2, y2) {
          return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
        }

        function puntoEstaDentroDelCirculo(posx, posy, x, y, radio) {
            return (distancia2(posx, posy, x, y) < radio * radio);
        }

        function inicializaTablero() {
            for (let f = 0; f < filas; f++) {
                matrizColores[f] = [];
                for (let c = 0; c < columnas; c++) {
                    matrizColores[f][c] = 0;    // 0: blanco, 1: rojo, 2: amarillo
                }
            }
        }   

        // hay un espacio vacio ?
        function encontrarFila(columna) {
            for (let fila = filas - 1; fila >= 0; fila--) {
                if (matrizColores[fila][columna] === 0) {
                    return fila;
                }
            }
            return -1; // Columna llena
        }

        function verificaGanador(fila, columna, jugador) {
            // horizontal
            let count = 0;
            for (let c = 0; c < columnas; c++) {
                if (matrizColores[fila][c] === jugador) {
                    count++;
                } else {
                    count = 0;
                }
                if (count >= 4) return true;
            }

            // vertical
            count = 0;
            for (let f = 0; f < filas; f++) {
                if (matrizColores[f][columna] === jugador) {
                    count++;
                } else {
                    count = 0;
                }
                if (count >= 4) return true;
            }

            // diagonalmente \
            count = 0;
            let startRow = fila - Math.min(fila, columna);
            let startCol = columna - Math.min(fila, columna);
            for (let i = 0; i < Math.min(filas - startRow, columnas - startCol); i++) {
                if (matrizColores[startRow + i][startCol + i] === jugador) {
                    count++;
                } else {
                    count = 0;
                }
                if (count >= 4) return true;
            }

            // diagonal /
            count = 0;
            startRow = fila - Math.min(fila, columnas - 1 - columna);
            startCol = columna + Math.min(fila, columnas - 1 - columna);
            for (let i = 0; i < Math.min(filas - startRow, startCol + 1); i++) {
                if (matrizColores[startRow + i][startCol - i] === jugador) {
                    count++;
                } else {
                    count = 0;
                }
                if (count >= 4) return true;
            }

        return false;
        }

        function Empate() {
            for (let fila = 0; fila < filas; fila++) {
                for (let columna = 0; columna < columnas; columna++) {
                    if (matrizColores[fila][columna] === 0) {
                        return false;
                    }
                }
            }
            return true;
        }

        function mouseDown(event) {
            var posx = new Number();
            var posy = new Number();

            /* Obtiene la coordenada dentro del canvas */
            posx = event.x - canvas.offsetLeft;
            posy = event.y - canvas.offsetTop;
            /* En coordenadas del OpenGL */
            posx = ((posx / ancho) * 10) - 5;
            //posy = ((1 - posy / alto) * 10) - 5;
            
            //let puntosx=[-4,-2.65,-1.29,0.05,1.4,2.75,4.1];
            //let puntosy=[4,2.5,1,-0.5,-2,-3.5];
            //buscamos la posicion elegida
           
            for (let c = 0; c < columnas; c++) {
                let x = -4 + c * 1.35;
                if (posx > x - 0.5 && posx < x + 0.5) {
                    let filaDisponible = encontrarFila(c);
                    if (filaDisponible !== -1) {
                        matrizColores[filaDisponible][c] = turnoJugador;
                        dibuja();
                        if (verificaGanador(filaDisponible, c, turnoJugador)) {
                            let colorGanador = (turnoJugador === 1) ? 'Rojo' : 'Amarillo';
                            setTimeout(() => {
                            alert('¡El jugador ' + colorGanador + ' ha ganado!');
                            inicializaTablero();
                            dibuja();
                            }, 100);
                        } else if (Empate()) {
                            setTimeout(() => {
                            alert('¡Es un empate!');
                            inicializaTablero();
                            dibuja();
                            }, 100);
                        } else {
                            turnoJugador = (turnoJugador === 1) ? 2 : 1;
                            actualizaTurno();
                        }
                    }
                    return;
                }
            }
        }

        function actualizaTurno() {
            if (turnoJugador === 1) {
                turnoTexto.textContent = "Turno del jugador: Rojo";
                turnoTexto.style.color = "red";
            } else {
                turnoTexto.textContent = "Turno del jugador: Amarillo";
                turnoTexto.style.color = "yellow";
            }
        }

        function dibuja() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            // Bucle para 6 filas
            for(let f = 0; f < filas; f++){
                // Bucle para 7 columnas
                for(let c = 0; c < columnas; c++){
                    // Se calcula la posición de cada círculo
                    let x = -4 + c * 1.35;
                    let y = 4 - f * 1.5;

                    // obtenemos el color 
                    let colorActual;
                    if (matrizColores[f][c] === 1) {
                        colorActual = [1, 0, 0, 1]; // Rojo
                    } else if (matrizColores[f][c] === 2) {
                        colorActual = [1, 1, 0, 1]; // Amarillo
                    } else {
                        colorActual = [1,1,1, 1]; // Blanco
                    }

                    //envia los colores 
                    circulo.actualizaColor(Array(360).fill(0).flatMap(() => colorActual));

                    identidad(MatrizModelo);
                    traslacion(MatrizModelo, x, y, 0);
                    gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
                    circulo.dibuja(gl, true);
                }
            }
        }

        function main() {
            canvas = document.getElementById("webglcanvas");

            gl = canvas.getContext("webgl2");
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            /* Se indica al canvas que detecte los eventos del ratón */
            canvas.addEventListener("mousedown", mouseDown, false);

            compilaEnlazaLosShaders();

            circulo = new Circulo(gl, 0.5);

            gl.useProgram(programaID);

            /* Obtiene los ID de las variables de entrada de los shaders */
            uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
            uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
            uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");

            // Define la Matriz de Proyección
            ortho(MatrizProyeccion, -5, 5, -5, 5, -5, 5);
            gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

            identidad(MatrizVista);
            gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
            gl.clearColor(0, 0, 65/255,1);
            inicializaTablero();
            dibuja();
        }
        window.onload = main;
    </script>
      
</body>

</html>
